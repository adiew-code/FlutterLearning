## Go 语言学习

#### 1、未初始化变量，都有默认值

- ###### 数值类型

  | 类型   |               默认值               |
  | ------ | :--------------------------------: |
  | 布尔   |               false                |
  | String |                 ""                 |
  | int    |                 0                  |
  | 数组   | 每个元素或字段都是对应该类型的零值 |
  | 结构体 | 每个元素或字段都是对应该类型的零值 |

- ###### 接口或引用类型

  | 类型  | 默认值 |
  | ----- | ------ |
  | slice | nil    |
  | 指针  | nil    |
  | map   | nil    |
  | chan  | nil    |
  | 函数  | nil    |
  |       |        |

#### 2、变量声明

**Note：**包级变量的声明顺序随意，但是函数内部定义的变量必须先定义后使用

```go
///批量声明多个变量
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

局部变量可以使用简短声明

```go
///类型根据初始值自动推断
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
///也可以批量定义多个变量，如果其中某些在上面已经定义了，那相当于赋值；但必须至少要声明一个新的变量
i, j := 0, 1

///注意⚠️简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
```

```go
///比如下面就会编译错误
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

**⚠注意：**不要和多重赋值搞混了，例如：

```go
i, j = j, i // 交换 i 和 j 的值,这是赋值操作，不是定义变量
```

#### 3、变量的生命周期

| 变量生命周期     | Go                             | C            | C++            | Objective-C  | Swift        |
| ---------------- | ------------------------------ | ------------ | -------------- | ------------ | ------------ |
| 全局变量         | 这是包一级声明的变量，一直存在 | 一直存在     | 一直存在       | 一直存在     | 一直存在     |
| 函数内部局部变量 | 自动垃圾收集器跟踪是否可达？   | 退出作用域后 | 退出作用域后   | 退出作用域后 | 退出作用域后 |
| new 创建的变量   | 自动垃圾收集器跟踪是否可达？   | 手动调用free | 手动调用delete | 引用计数为0  | NA           |

由此我们得出go语言以下结论：

***使用var定义的变量，和使用new定义的变量没多大区别。变量是否回收，跟它是局部变量无关（即便函数返回；new定义的变量也不一定在堆上。***

```go
var global *int

func f() {
    var x int ///你以为上在栈上，其实在堆上
    x = 1
    global = &x
}
func f1() *int {
    v := 1 ///看起来是局部变量，其实在堆上分配的，所以函数返回其地址是OK
    return &v ///返回其地址
}
func g() {
    y := new(int) ///你以为是在堆上，其实是在栈上
    *y = 1
}
```

**⚠注意**：这是跟其他编程语言很大的不同，go语言的垃圾回收机制为我们做了这些，我们几乎不用关心内存管理

#### 4、++、-- 操作是语句，不是表达式

这也是跟C、C++的不同之处。C中i++和++i，都是有不同的，初学者容易晕。

```go
v := 1
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
v = v++ ///错误，v++是语句，不是表达式
```

#### 5、多重赋值

这也是大部分语言不具备的语法，看起来有一定迷惑性。

```go
x, y = y, x  ///交换x、y的值
///注意，编译器会先把右侧所有表达式一次性算出来，然后在批量赋值给左侧变量
///而不是逐个赋值,试想一下如下代码，跟上面的结果完全不一致
/// x = y
/// y = x
a[i], a[j] = a[j], a[i]
```

#### 6、每个go文件，都可以有一个init方法，程序加载时自动调用且只调用一次

这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用，根据依赖情况，先初始化依赖的包,main包最后被初始化。

#### 7、访问权限

首字母大写的方法、类型、变量可以被其他包引用。it's easy as abc!

#### 8、defer函数

#### 9、异常捕获

#### 10、参数传递——pass by Value 传值

#### 11、Interface接口

#### 12、channel通道

#### 13、select多路复用

#### 14、闭包对外部变量的捕获方式

#### 15、数组和Slice

- 数组定义
- Slice定义

#### 16、反射

#### 17、锁